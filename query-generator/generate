#!/usr/bin/env python3
# vi: set syntax=python:
import re
import sys
import shutil
import os
from os.path import join, isfile, dirname

PATTERN_SIMPLE_IMPORT = re.compile('^\s*import\s+([a-zA-Z0-9_]+)\s*$', flags=re.MULTILINE)
PATTERN_COMMENT_LINES = re.compile('^\s*//.*$', flags=re.MULTILINE)
PATTERN_METADATA = re.compile('^\s*/\*\*(.(?!\*/))*.\*/', flags=re.DOTALL)
PATTERN_METADATA_LINE = re.compile('@(\S+)\s+(\S+)')
PATTERN_FROM_WHERE_SELECT = re.compile('^\s*from\s+(.*)\s+where\s+(.*)\s+select\s+(.*)\s*', re.DOTALL | re.MULTILINE)
CONFIG_CLASS = 'class\s+(\S+)\s+extends\s+(\S+Configuration)\s+{'
PATTERN_PUBLIC_CONFIG_CLASS_DEF = re.compile('^\s*{config_class}'.format(config_class=CONFIG_CLASS), flags=re.MULTILINE | re.DOTALL)
PATTERN_PRIVATE_CONFIG_CLASS_DEF = re.compile('^\s*private\s+{config_class}'.format(config_class=CONFIG_CLASS), flags=re.MULTILINE | re.DOTALL)
PATTERN_HASFLOW_CALL = re.compile('(\S+)\.hasFlow(Path)?\s*\(', flags=re.DOTALL)
PATTERN_PATHGRAPH_IMPORT = re.compile('^\s*import\s+(\S*PathGraph)', flags=re.MULTILINE | re.DOTALL)

SS_QLHEADER ='''/**
 * @name Sources and Sinks
 * @description Prints sources and sinks of various DataFlow and TaintTracking Configurations
 * @kind problem
 * @problem.severity recommendation
 * @id {id}
 */
'''


SS_QLBODY ='''
from DataFlow::Node n, string type
where exists(string qid | qid = "{qid}" and ({body}))
select n, type
'''

SS_BODY_CLAUSE = '''
  exists(
    {config} c |
    c.isSource(n) and type = qid + " | " + c + " | " + "Source" or
    c.isSink(n)   and type = qid + " | " + c + " | " + "Sink"
  )
'''

SSC_QLBODY ='''
from string type, int amount
where exists(string qid | qid = "{qid}" and ({body}))
select type, amount
'''

SSC_BODY_CLAUSE ='''
  exists(
    {config} c |
    amount = count(DataFlow::Node n | c.isSource(n)) and type = qid + " | " + c + " | " + "Source" or
    amount = count(DataFlow::Node n | c.isSink(n))   and type = qid + " | " + c + " | " + "Sink"
  )
'''

lang = sys.argv[1]
fname = sys.argv[2]
fdir = dirname(fname)
with open(fname, 'r') as f:
  contents = f.read()

# remove comment lines
contents = PATTERN_COMMENT_LINES.sub('', contents)

# remove PathGraph imports
contents = PATTERN_PATHGRAPH_IMPORT.sub('', contents)

def get_metadata(querystring):
  result = {}
  m = PATTERN_METADATA.search(querystring)
  if m:
    for ml in PATTERN_METADATA_LINE.findall(m.group(0)):
      result[ml[0]] = ml[1]
  return result


def get_simple_imports(querystring):
  return PATTERN_SIMPLE_IMPORT.findall(querystring)


def from_where_select(querystring):
  m = PATTERN_FROM_WHERE_SELECT.search(querystring)
  return (m.group(1), m.group(2), m.group(3)) if m else (None, None, None)


def get_flow_config_types_from_class_definitions(querystring):
  return [m[0] for m in PATTERN_PUBLIC_CONFIG_CLASS_DEF.findall(querystring)]


def get_flow_config_types_from_query_body(querystring):
  result = []
  f, w, s = from_where_select(querystring)
  if not(f and w):
    return None
  for m in re.findall(PATTERN_HASFLOW_CALL, w):
    qualifier = m[0]
    for d in f.split(','):
      d = d.strip()
      dtype = re.split('\s+', d)[0]
      dvarname = re.split('\s+', d)[1]
      if dvarname == qualifier:
        result.append(dtype)
  return result


def get_flow_config_types(fname, querystring):
  result = set()
  for si in get_simple_imports(querystring):
    qll_fname = join(dirname(fname), si + ".qll")

    if isfile(qll_fname):
      qll_contents = ''

      with open(qll_fname, 'r') as f:
        # make private Configuration classes public (this is a very shaky approach, but works for now)
        qll_contents = PATTERN_PRIVATE_CONFIG_CLASS_DEF.sub(r'class \1 extends \2 {', f.read())

      with open(qll_fname, 'w') as f:
        f.write(qll_contents)

      result.update(get_flow_config_types_from_class_definitions(qll_contents))

  result.update(get_flow_config_types_from_query_body(querystring))
  result.update(get_flow_config_types_from_class_definitions(querystring))

  return sorted(result)


metadata = get_metadata(contents)

if metadata.get('kind', 'UNDEFINED') == 'path-problem':
  fcts = get_flow_config_types(fname, contents)

  if not fcts:
    print('WARNING: Did not find any flow configuration types for "{fname}"!'.format(fname=fname))
    sys.exit(0)

  name = metadata['id'].replace('/', '__').replace('-', '_')
  ssdir = join('sources-and-sinks', name)
  sscdir = join('source-and-sink-counts', name)
  os.makedirs(ssdir, exist_ok=True)
  os.makedirs(sscdir, exist_ok=True)

  # copy library files shipping with the given query
  for f in os.listdir(fdir):
    if f.endswith('.qll'):
      shutil.copyfile(join(fdir, f), join(ssdir, f))
      shutil.copyfile(join(fdir, f), join(sscdir, f))

  ssqlname = join(ssdir, 'query.ql')
  sscqlname = join(sscdir, 'query.ql')

  with open(ssqlname, 'w') as f:
    f.write(
      SS_QLHEADER.format(
        id=metadata['id'] + '-sources-and-sinks'
      )
    )
    f.write(PATTERN_FROM_WHERE_SELECT.sub('', PATTERN_METADATA.sub('', contents)))
    body = '  or'.join([SS_BODY_CLAUSE.format(config=t) for t in fcts])
    f.write(SS_QLBODY.format(body=body, qid=metadata['id']))

  with open(sscqlname, 'w') as f:
    f.write(PATTERN_FROM_WHERE_SELECT.sub('', PATTERN_METADATA.sub('', contents)))
    body = '  or'.join([SSC_BODY_CLAUSE.format(config=t) for t in fcts])
    f.write(SSC_QLBODY.format(body=body, qid=metadata['id']))
